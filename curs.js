let currentSlide = 0;
let isAnimating = false;

const slideTitles = [
    "О курсе",
    "О курсе",
    "Создание проекта",
    "Спрайты для игры",
    "Создание платформы",
    "Создание платформы",
    "Настройка фона",
    "Настройка фона",
    "Настройка фона",
    "Настройка фона",
    "Настройка фона",
    "Настройка фона",
    "Добавление персонажа",
    "Добавление персонажа",
    "Добавление персонажа",
    "Анимирование бега",
    "Анимирование бега",
    "Анимирование бега",
    "Анимирование бега",
    "Управление движением игрока",
    "Синхронизация анимаций и движения",
    "Рекомендации",
    "Конец первой части",
]

const slideTexts = [
    "Сегодня расскажем, как создать 2D-платформер в Unity. Это увлекательный жанр, в котором вам нужно перемещаться по уровням. Играя в такие игры, можно легко привыкнуть к механике, а вот разрабатывать их — настоящее удовольствие.",
    "Давайте пошагово разберемся, начинающим программистам создать подобную игру в Unity. Перед тем, как начать, откройте Unity и создайте новый 2D проект.",
    "Присвойте ему имя и нажмите Create Project.",
    "Для начала вам понадобятся спрайты для игры. Их можно создать самостоятельно или скачать с различных сайтов, например, на AssetStore или на нашем сайте на главной странице. Важно, чтобы у вас были спрайты для персонажа, платформ и фона. Загружаем их и импортируем в проект.",
    "Используем спрайт земли, чтобы собрать платформу. Для удобства перемещаем окно игры рядом с окном сцены. Чтобы быстрее создать платформу, нажимаем CTRL+D, чтобы дублировать блоки земли. Перетаскивание с зажатым CTRL будет перемещать элементы по сетке, что поможет выровнять их. Дублируем блоки до тех пор, пока не получится нужная длина платформы. ",
    "Все элементы можно собрать в пустой объект, чтобы перемещать и масштабировать платформу целиком.",
    "Создаем Canvas (полотно), на котором разместим задний фон.",
    "Добавляем в Canvas картинку.",
    "Масштабируем Canvas в зависимости от разрешения экрана. Для этого вручную задаем размеры.",
    "Затем импортируем изображение фона и устанавливаем его в качестве текстуры. ",
    "Чтобы текстура повторялась без растяжения, выбираем параметр Tiled. При удержании Alt текстура автоматически растягивается на всю сцену.",
    "Выбираем нашу камеру для Canvas.",
    "Перемещаем первый кадр анимации персонажа (например, для состояния покоя) на сцену. Увеличиваем его и убираем размытие у всех пиксельных спрайтов. ",
    "Добавляем Box Collider 2D для нашей платформы.",
    "Теперь создаем аниматор, чтобы управлять анимациями персонажа. В папке для анимаций создаем анимацию Idle (покой) и сохраняем ее. Затем перемещаем кадры в нужное положение. Скорость анимации можно отрегулировать либо растягиванием в редакторе анимации, либо через параметры в аниматоре.",
    "Добавляем анимацию бега и настраиваем переходы между анимациями. ",
    "Убираем галочку Has Exit Time для плавного перехода. ",
    "Создаем переменную isMoving, которая будет переключать персонажа из состояния покоя в движение и наоборот. Устанавливаем, что при значении isMoving = true будет воспроизводиться анимация бега, а при isMoving = false — анимация покоя.",
    "Добавляем для игрока Capsule Collider 2D, а так же Rigidbody 2D",
    "Создаем скрипт для управления движением персонажа. В нем задаем скорость движения и ссылку на компонент Rigidbody2D, который отвечает за физику объектов. В функции Start получаем этот компонент, а в функции Update будем обновлять движение персонажа каждый кадр, основываясь на нажатых клавишах. Используем Input.GetAxis('Horizontal'), чтобы читать клавиши A и D, и определяем направление движения. Для того чтобы персонаж правильно поворачивался, добавляем условие, которое будет изменять ориентацию персонажа в зависимости от направления его движения.",
    "Создаем отдельный скрипт для переключения анимаций. В нем добавляем переменную для хранения ссылки на аниматор и на переменную isMoving, которая будет отвечать за состояние анимации. В функции Update синхронизируем переменную isMoving с аниматором, обновляя ее в зависимости от направления движения. Теперь в скрипте управления движением добавляем ссылку на этот скрипт и обновляем состояние переменной isMoving, чтобы анимация менялась вместе с движением персонажа.",
    "Теперь можно запускать игру и проверять работу анимаций и движения. Вы можете поэкспериментировать с разными параметрами, например, изменить скорость персонажа или добавить новые анимации.",
    "Таким образом, мы завершили создание базового 2D-платформера в Unity. Теперь у вас есть все необходимое для того, чтобы начать разрабатывать свою собственную игру! Экспериментируйте с механиками, меняйте персонажа, среду и создавайте уникальные уровни!",

];


function moveSlide(step) {
    if (isAnimating) return;
    isAnimating = true;

    const slides = document.querySelectorAll('.slide');
    const totalSlides = slides.length;
    const slider = document.querySelector('.slider');
    const slideTextElement = document.getElementById('slideText');
    const slideTitleElement = document.getElementById('slideTitle');

    // Анимация исчезновения текста
    slideTextElement.classList.add('fade-out');
    slideTitleElement.classList.add('fade-out');

    // Плавное обновление слайда
    currentSlide = (currentSlide + step + totalSlides) % totalSlides;
    slider.style.transform = `translateX(-${currentSlide * 100}%)`;
    updateProgressBar();

    // Обновляем контент после небольшой задержки
    setTimeout(() => {
        slideTitleElement.textContent = slideTitles[currentSlide];
        slideTextElement.textContent = slideTexts[currentSlide];
    }, 150); // Задержка для синхронизации с анимацией

    // Анимация появления текста
    setTimeout(() => {
        slideTextElement.classList.remove('fade-out');
        slideTitleElement.classList.remove('fade-out');
        slideTextElement.classList.add('fade-in');
        slideTitleElement.classList.add('fade-in');
    }, 300);

    // Сброс флага
    setTimeout(() => {
        slideTextElement.classList.remove('fade-in');
        slideTitleElement.classList.remove('fade-in');
        isAnimating = false;
    }, 600); // Общее время анимации
}
function updateProgressBar() {
    const totalSlides = document.querySelectorAll('.slide').length;
    const progress = ((currentSlide + 1) / totalSlides) * 100; // +1, если слайды нумеруются с 0
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    
    progressBar.style.width = `${progress}%`;
    progressText.textContent = `${Math.round(progress)}%`;
}

// Инициализация при загрузке
window.addEventListener('load', () => {
    updateProgressBar();
});


document.addEventListener("DOMContentLoaded", function () {
    const links = document.querySelectorAll("a"); // Находим все ссылки

    links.forEach(link => {
        link.addEventListener("click", function (e) {
            if (link.getAttribute("target") === "_blank") return; // Игнорируем ссылки, открывающиеся в новом окне
            
            e.preventDefault(); // Отменяем стандартный переход
            const href = this.href; // Получаем ссылку

            document.body.classList.add("fade-out"); // Добавляем эффект исчезновения

            setTimeout(() => {
                window.location.href = href; // Через 500мс переходим на новую страницу
            }, 500);
        });
    });
});